# vigenere

What problems are you solving in this project?


What solutions are you implementing in the project?

Provide explanation of calculations and algorithm implementation.

What is the program objectives? Explain how your program is interacting with the user
and its purpose.

How is discrete structures implemented in the C++ program?

What are the limitations of the program?

Provide recommendation on improving the limitations of the program



The Vigenere receives user text and a user-specified key which is used to encrypt or decrypt the text according to the set of symbols chosen by the user. The first set of symbols are the UPPERCASE letters from A-Z. (26 characters). The second set of symbols are the printable ASCII characters from 3310 to 12610. (93 Symbols). After the user inputs their selection for Encryption/Decryption, the program then prompts the user for the size of the Vigenere Table used to encrypt the text. (26x26 or 93x93). The user is then prompted for the text to be transformed and the key to be used. The program then computes the result and prompts the user to run again. 
	
Some of the problems I encountered were errors due to improper formatting of the text and key, invalid input when presented with menu choices and the implementation of an array whose size is not known at compile time. If the user wants to use the first set of symbols for encryption, (26x26) the only valid characters for the text and key are exclusively UPPERCASE letters. The ASCII range of these values are 6510 to 9010. The valid range of ASCII values for the larger Vigenere Table are 3310 to 12610. To resolve errors from having invalid characters in the text and key, spaces from both strings are removed, then the text and key are converted to UPPERCASE if the user is using the 26x26 Vigenere Table. The previous step is not necessary for the larger Vigenere Table because LOWERCASE and UPPERCASE characters, symbols and numbers are valid inputs. Then, both strings are checked for any characters outside the accepted range of ASCII values. If any are found, the user is notified and the characters are removed. In the event that the user only inputted invalid characters, a check is performed to make sure neither string is empty, which would cause errors if the program were to continue. A final check is performed on the user key’s length; If longer than the user text, it is trimmed. If shorter than the text, it is appended to itself until the length of the text and key are of equal length. The last problem I encountered was the declaration of an array to represent the Vigenere Table at compile time. I decided to declare 2 different Vigenere Tables and only fill the one used by the user with values. If I wanted to add functionality for the user to specify a specific Vigenere table size, I would approach the solution differently by using dynamic memory allocation. I decided to go with the former because only 2 differently sized arrays are used and the resource strain is relatively minimal. 

The program algorithm was fairly simple but challenging to implement. The process is identical when using the 26x26 or 93x93 array, just with different values for the cardinality of the set of valid symbols and specific variables to represent the ASCII starting index. The algorithm implemented in this program fills the user-specified Vigenere Table with appropriate values. Because the table is essentially a set of caesar ciphers with different shift values stacked on top of each other, it was necessary to write a function to fill the array with the correct values. With a nested for loop, the function iterates over every element in every row. For each element, the starting ASCII index is added to the sum of the row iterator modded by the sets cardinality and the column iterator modded by the sets cardinality, modded by the set cardinality. Because the iterators for the outer and inner for loop are also used as the index locations for row and column, when the starting ASCII index is added on each iteration, the result is a character with a shift value of the current row index. Essentially, modular arithmetic is used on the set of valid symbols to get the appropriate shift for each row in the Vigenere Table. To validate the appropriate values, a cout statement is written to output the values as they are filled. This is commented out in the source code by default. After the vigenere tables are filled, the algorithm then needs to determine the type of transformation to apply to the user text. This is decided by the user and the program shifts to either the encryption or decryption branch. When encrypting the user text, the algorithm iterates over each character in the user text. For each character, a lookup is performed on the Vigenere Table. The row index is represented by the difference from the ASCII value of the first character in the valid set of symbols and the current character in the user text. The row index is represented the same way but using the user key instead of the user text. The index of the user text and key is represented by the iterator resulting in the correct encrypted character. For Decryption, the algorithm performs a linear search on the Vigenere Table, starting with the first element of each row before moving to the next column, testing to see if the current character at that location minus the set cardinality is equal to that character in the text. The row index is represented by the iterator of the nested FOR loop and the column index is represented by the iterator in the outer FOR loop. When the text has been successfully transformed, the user's original text, original key, formatted text, formatted key, and finally the transformed text is output to the terminal. The user is then prompted to run the program again. 

The objective of this program was fairly simple; to let the user input text to encrypt or decrypt using a chosen key, then show the output. Because I wanted to allow the user to select from two Vigenere Table sizes, it was essential to interact with the user several times to receive operating parameters. The program interacts with the user a total of 4 times in main(). It begins by prompting the user to choose between encryption or decryption, then the standard or expanded Vigenere Table, the text to be transformed, and finally the key. 

Discrete Structures are implemented in this program by way of functions performing operations on discontinuous sets. For example, the valid members of alphabetic and alphanumeric sets. The symbols themselves are a subset of a larger group of printable ASCII characters. Several discrete structure concepts are utilized in the program such as user-defined strings with different cardinality, checking for members outside the set of valid symbols, modular arithmetic on integers representing the members of sets and subsets and rules of the functions that modify them. Although the program itself does not contain probability analysis, it could be utilized to estimate the worst-case scenario when attempting to brute force decryption. 

When considering the strength and weakness of the vigenere cipher and the program itself, one must  consider the fact that while the Vigenere cipher went unbroken for 300 years, this is no longer the case. One of the strengths of the Vigenere cipher is that it is resistant to frequency analysis due to the use of multiple ciphers with different shift values. A character won’t necessarily be substituted with the same symbol each time. Trying to brute force a standard Vigenere cipher is not an easy task, as the key adds a level of complexity making the the number of possible cases equal to nK , where n is equal to the cardinality of the valid set of symbols and k is equal to the length of the key. Although the key is a source of strength for the Vigenere cipher, it is also the source of it’s weakness due to its repetitive nature. If an individual were to guess the length of the key, then the cipher text can be split into individual Caesar ciphers which are much easier to brute force. If the ciphertext expresses repetition, it is also expressed in the plaintext. This method of analysis is known as the Kasiski examination. Although the strength and weaknesses of the Vigenere cipher are relatively clear, the program itself has its own set of limitations. First, it is entirely possible that the program won’t run correctly due to invalid input or the code breaking in some way. Second, declaring multiple containers but only utilizing one is inefficient. It became necessary to write multiple functions for each table which could quickly become exponentially inefficient. Utilizing vectors or dynamic memory allocation could improve the program's simplicity and reduce overall lines of code. Additionally, classes could be utilized. If one could make the key truly random, longer than the plaintext and only used once, it would become significantly more difficult to decrypt. External hardware could also be used as a vector of input for entropic data. Increasing the effective key length can be done by relatively prime key lengths and if the ciphertext is shorter than the effective key length the ciphertext becomes even more difficult to decode. 